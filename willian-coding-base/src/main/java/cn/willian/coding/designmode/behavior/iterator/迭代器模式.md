## 迭代器模式
迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式

* Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。
* ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。
* Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。
* ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。

## 类用例图

```mermaid
%% classDiagram 定义类图
%% - 私有
%% + 公有
%% # 受保护
%% ~ 包/内部
%% $ 静态方法、静态变量
%% * 抽象方法

%% <<interface>> 接口
%% <<abstract>> 抽象类
%% <<service>> 服务等级
%% <<enumeration>> 枚举

%% ..> 依赖：只要在类中引用了另一个类的类，那么它们之间就是依赖关系。比如类A中有方法m，方法m的返回值类型为类B，此时，类A与类B依赖。
%% --> 关联：相较于依赖关系，关联关系的依赖性更高。比如类A中有成员属性b，此时类A与类B关联。
%% --o 聚合：关联性是更强的关联关系。是整体和个体的关系。但二者可分割。比如类A中有成员属性b，并且属性b通过setter赋值，此时二者就是聚合关系。
%% *-- 组合: 关联性是更强的关联关系。是整体和部分的关系。二者不可分割。比如类A中有成员属性b，并且属性b是在类A的构造方法中赋值，此时二者就是组合关系。
%% ..|> 实现: 类A实现了类B（接口或抽象类）
%% -–|> 继承: 类A继承了类B

classDiagram
    
class Iterator{
    <<interface>>
    +first()
    +next()
    +hasNext()
    +currentItem()
}

class ConcreteIterator{
    +first()
    +next()
    +hasNext()
    +currentItem()
}

class Aggregate{
    +createIterator()
}

class ConcreteAggregate{
    +createIterator()
}

ConcreteAggregate ..|> Aggregate
ConcreteIterator ..|> Iterator

ConcreteIterator --> ConcreteAggregate : aggregate
ConcreteAggregate ..> ConcreteIterator

```