## 策略模式
策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。

* Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。
* Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。
* ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。

## 类用例图

```mermaid
%% classDiagram 定义类图
%% - 私有
%% + 公有
%% # 受保护
%% ~ 包/内部
%% $ 静态方法、静态变量
%% * 抽象方法

%% <<interface>> 接口
%% <<abstract>> 抽象类
%% <<service>> 服务等级
%% <<enumeration>> 枚举

%% ..> 依赖：只要在类中引用了另一个类的类，那么它们之间就是依赖关系。比如类A中有方法m，方法m的返回值类型为类B，此时，类A与类B依赖。
%% --> 关联：相较于依赖关系，关联关系的依赖性更高。比如类A中有成员属性b，此时类A与类B关联。
%% --o 聚合：关联性是更强的关联关系。是整体和个体的关系。但二者可分割。比如类A中有成员属性b，并且属性b通过setter赋值，此时二者就是聚合关系。
%% *-- 组合: 关联性是更强的关联关系。是整体和部分的关系。二者不可分割。比如类A中有成员属性b，并且属性b是在类A的构造方法中赋值，此时二者就是组合关系。
%% ..|> 实现: 类A实现了类B（接口或抽象类）
%% -–|> 继承: 类A继承了类B

classDiagram
    
class Context{
    - strategy : Strategy
    + algorithm()
}
note for Context "....\n strategy.algorithm();\n...."

class Strategy{
    + algorithm()
}

class ConcreteStrategyA{
    + algorithm()
}

class ConcreteStrategyB{
    + algorithm()
}

ConcreteStrategyA ..|> Strategy
ConcreteStrategyB ..|> Strategy
Context o-- Strategy : strategy
```