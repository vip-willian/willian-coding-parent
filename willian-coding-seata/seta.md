## AT模式可能出现脏写问题，引入全局锁去解决

并发修改同一个数，可能会出现脏写问题

lock_table

事务A 持有 全局锁
事务B 等待 全局锁

事务A 回滚 等待DB锁
事务B 持有 DB锁

导致出现死锁
事务B 等待全局锁设置超时重试 默认30次，间隔10ms
回滚并释放DB锁

## AT模式的写隔离

记录写之前的快照
记录写之后的快照
确保在第二阶段提交的时候，不会有其他的线程执行再次的修改
告警通知，需要人工记录

# XA模式 (强一致性)

一阶段执行后，不进行提交，占用数据库锁

# AT模式 (最终一致性)
一阶段执行后，直接提交，记录undo_log表


# TCC模式 (最终一致性)
基于业务代码，来实现2阶段提交

- try: 将100元分为30和70，30为冻结金额，70为可用余额
- confirm: 将冻结金额扣减30
- cancel: 可用金额增加30

confirm 和 cancel 可能会失败，seata会进行业务重试，需要业务做好幂等

AT + TCC 可以混搭

允许空回滚： 可能没执行try, 但是 事务超时阻塞，需要进行回滚，调用cancel。
拒绝业务悬挂：已经执行了cancel, 但是事务超时阻塞恢复，重新执行了try ，业务一直挂起
 
